#include <game/game_stage.h>
#include <game/shared/shared_res.h>
#include <game/shared/map_object_meta.h>
#include <game/shared/structure_meta.h>

#include <loaders/resource_file.h>
#include <graphics/soaspritergb.h>
#include <graphics/soaspritergba.h>
#include <graphics/Sprite256.h>
#include <graphics/font_rendering.h>
#include <graphics/tilemap/tilemap.h>
#include <loaders/ksy/rage_of_mages_1_alm.h>
#include <util/macro_shared.h>
#include <emmintrin.h>
#include <game/game.h>
#include <chrono>
#include <assert.h>
#include <cmath>
#include <thread>
#include <future>
#include <queue>

namespace {
    enum {
        SCROLL_SPEED = 16,
        MAX_ALTITUDE = 255,
        STANDART_TILE_HEIGHT = 32,
        MAX_COLUMN_HEIGHT = (MAX_ALTITUDE + STANDART_TILE_HEIGHT)
    };
/*
  MAX_COLUMN_HEIGHT times of repetitions for each pixel of a tile column

  originally generated by a call to init_height_scaler_lookup()
  then printed as hardcode version
*/
    uint8_t height_scaler_lookup[STANDART_TILE_HEIGHT * (MAX_COLUMN_HEIGHT + 2)] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
        1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
        1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
        1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
        1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
        1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
        1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
        1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
        2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
        2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
        2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2,
        2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2,
        2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2,
        2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2,
        2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2,
        2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2,
        2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2,
        2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
        2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
        2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
        2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
        2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
        2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,
        3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,
        3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,
        3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3,
        3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3,
        3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3,
        3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3,
        3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3,
        3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3,
        3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3, 2, 2, 3,
        3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
        3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
        3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
        3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
        3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
        3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4,
        4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4,
        4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4,
        4, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 4,
        4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4,
        4, 3, 3, 3, 3, 4, 3, 3, 3, 3, 4, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 4, 3, 3, 3, 3, 4,
        4, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3, 4,
        4, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3, 4,
        4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 3, 3, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4,
        4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4,
        4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4,
        4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4,
        4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4,
        4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 3, 4, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4,
        4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4,
        4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 4, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
        5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
        5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
        5, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4, 5,
        5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5,
        5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5,
        5, 4, 4, 4, 5, 4, 4, 4, 5, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 5, 4, 4, 4, 5, 4, 4, 4, 5,
        5, 4, 4, 4, 5, 4, 4, 4, 5, 4, 4, 4, 5, 4, 4, 5, 4, 4, 4, 5, 4, 4, 4, 5, 4, 4, 4, 5, 4, 4, 4, 5,
        5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5,
        5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5,
        5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5,
        5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5,
        5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 4, 4, 4, 4, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5,
        5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 4, 5, 4, 4, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5,
        5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5,
        5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 5, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6,
        6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6,
        6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6,
        6, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5, 6,
        6, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 6,
        6, 5, 5, 5, 5, 6, 5, 5, 5, 5, 6, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 6, 5, 5, 5, 5, 6,
        6, 5, 5, 5, 6, 5, 5, 5, 6, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 6, 5, 5, 5, 6, 5, 5, 5, 6,
        6, 5, 5, 5, 6, 5, 5, 5, 6, 5, 5, 5, 6, 5, 5, 6, 5, 5, 5, 6, 5, 5, 5, 6, 5, 5, 5, 6, 5, 5, 5, 6,
        6, 5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5, 5, 5, 5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5, 6,
        6, 5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5, 6, 5, 5, 6,
        6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6,
        6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6,
        6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 5, 5, 5, 5, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6,
        6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 5, 6, 5, 5, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6,
        6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6,
        6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 6, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 6, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
        7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
        7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
        7, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 7,
        7, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 7,
        7, 6, 6, 6, 6, 7, 6, 6, 6, 6, 7, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 7, 6, 6, 6, 6, 7,
        7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7,
        7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7,
        7, 6, 6, 7, 6, 6, 7, 6, 6, 7, 6, 6, 7, 6, 6, 6, 6, 6, 6, 7, 6, 6, 7, 6, 6, 7, 6, 6, 7, 6, 6, 7,
        7, 6, 6, 7, 6, 6, 7, 6, 6, 7, 6, 6, 7, 6, 6, 7, 6, 6, 6, 7, 6, 6, 7, 6, 6, 7, 6, 6, 7, 6, 6, 7,
        7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7,
        7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7,
        7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 6, 6, 6, 6, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7,
        7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 6, 7, 6, 6, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7,
        7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7,
        7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 7, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 7, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8,
        8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8,
        8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8,
        8, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 8,
        8, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 8,
        8, 7, 7, 7, 7, 8, 7, 7, 7, 7, 8, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 8, 7, 7, 7, 7, 8,
        8, 7, 7, 7, 8, 7, 7, 7, 8, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 8, 7, 7, 7, 8, 7, 7, 7, 8,
        8, 7, 7, 7, 8, 7, 7, 7, 8, 7, 7, 7, 8, 7, 7, 8, 7, 7, 7, 8, 7, 7, 7, 8, 7, 7, 7, 8, 7, 7, 7, 8,
        8, 7, 7, 8, 7, 7, 8, 7, 7, 8, 7, 7, 8, 7, 7, 7, 7, 7, 7, 8, 7, 7, 8, 7, 7, 8, 7, 7, 8, 7, 7, 8,
        8, 7, 7, 8, 7, 7, 8, 7, 7, 8, 7, 7, 8, 7, 7, 8, 7, 7, 7, 8, 7, 7, 8, 7, 7, 8, 7, 7, 8, 7, 7, 8,
        8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8,
        8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8,
        8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 7, 7, 7, 7, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8,
        8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 7, 8, 7, 7, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8,
        8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8,
        8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 8, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
        9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
        9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
        9, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 9,
        9, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 9,
        9, 8, 8, 8, 8, 9, 8, 8, 8, 8, 9, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 9, 8, 8, 8, 8, 9,
        9, 8, 8, 8, 9, 8, 8, 8, 9, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 9, 8, 8, 8, 9, 8, 8, 8, 9,
        9, 8, 8, 8, 9, 8, 8, 8, 9, 8, 8, 8, 9, 8, 8, 9, 8, 8, 8, 9, 8, 8, 8, 9, 8, 8, 8, 9, 8, 8, 8, 9,
        9, 8, 8, 9, 8, 8, 9, 8, 8, 9, 8, 8, 9, 8, 8, 8, 8, 8, 8, 9, 8, 8, 9, 8, 8, 9, 8, 8, 9, 8, 8, 9,
        9, 8, 8, 9, 8, 8, 9, 8, 8, 9, 8, 8, 9, 8, 8, 9, 8, 8, 8, 9, 8, 8, 9, 8, 8, 9, 8, 8, 9, 8, 8, 9,
        9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9,
        9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9,
        9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 8, 8, 8, 8, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9,
        9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 8, 9, 8, 8, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9,
        9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9,
        9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 9, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 9, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9
    };

    float normal_map[3 * 256 * 256];
    uint8_t lightness_map[256*256];
    uint8_t fov_map[256*256];
    uint8_t fov_map_shifted[256*256];
    uint8_t tile_selection_x = 255;
    uint8_t tile_selection_y = 255;

    void init_height_scaler_lookup() {
        for(size_t i = 0; i < STANDART_TILE_HEIGHT * (MAX_COLUMN_HEIGHT + 1); ++i) {
            height_scaler_lookup[i] = 0;
        }

        uint8_t* buffer_portion = &height_scaler_lookup[0];

        for(uint16_t i = 0; i <= MAX_COLUMN_HEIGHT; ++i) {
            uint8_t guaranteed_h = static_cast<uint8_t>(i / 32);
            if(guaranteed_h > 0) {
                for(size_t idx = 0; idx < 32; ++idx)
                buffer_portion[idx] = guaranteed_h;
            }
            size_t remain = i % 32;
            if(remain > 0) {
                size_t even_count = remain / 2;
                size_t has_center = remain % 2;
                if(has_center) {
                    buffer_portion[15]++;
                }
                if(even_count > 0) {
                    size_t strip_length = 32 / (remain - 1);
                    size_t offset = 0;
                    for(size_t j = 0; j < even_count; ++j) {
                        buffer_portion[offset]++;
                        buffer_portion[31 - offset]++;
                        offset += strip_length;
                    }
                }
            }
            buffer_portion += STANDART_TILE_HEIGHT;
        }
    }
}
#define CHECK_SCALER_RANGE(x) LOG_ASSERT(STANDART_TILE_HEIGHT * (x) < STANDART_TILE_HEIGHT * (MAX_COLUMN_HEIGHT + 2))
#define ACQUIRE_HEIGHT_SCALER(x) &height_scaler_lookup[STANDART_TILE_HEIGHT * (x)]

namespace Game {
    namespace GameStage {
        MapObject::MapObject(int32_t p_coord_x,
                             int32_t p_coord_y,
                             int32_t p_depth,
                             int32_t p_phase_ticks_remain,
                             int32_t p_current_phase,
                             int32_t p_meta_id,
                             object_state p_state,
                             std::shared_ptr<Sprite256> p_sprite):
            coord_x{p_coord_x}, coord_y{p_coord_y},
            depth{p_depth}, phase_ticks_remain{p_phase_ticks_remain},
            current_phase{p_current_phase}, meta_id{p_meta_id},
            state{p_state}, sprite{p_sprite}{}
        Structure::Structure(int32_t p_coord_x,
                             int32_t p_coord_y,
                             int32_t p_depth,
                             int32_t p_phase_ticks_remain,
                             int32_t p_current_phase,
                             int32_t p_meta_id,
                             uint16_t p_bridge_info_id,
                             uint16_t p_fraction_id,
                             uint16_t p_health,
                             std::shared_ptr<Sprite256> p_sprite):
            coord_x{p_coord_x}, coord_y{p_coord_y},
            depth{p_depth}, phase_ticks_remain{p_phase_ticks_remain},
            current_phase{p_current_phase}, meta_id{p_meta_id},
            bridge_info_id{p_bridge_info_id}, fraction_id{p_fraction_id},
            health{p_health}, sprite{p_sprite}{}

        Stage::Stage(uint16_t window_width,
                     uint16_t window_height) :
                water_offset_{0},
                window_width_{window_width},
                window_height_{window_height},
                fov_sprite_{window_width, window_height},
                tiles_sprite_{window_width, window_height},
                shadow_offset_{128} {
            terrain_cache_ = new uint8_t[6 * window_width_ * window_height_];
            size_t offset = 0;

            render_shared_.terrain_tile_high_byte_cache = &terrain_cache_[offset];
            offset += window_width * window_height;
            render_shared_.terrain_tile_low_byte_cache = &terrain_cache_[offset];
            offset += window_width * window_height;
            render_shared_.terrain_tile_u_cache = &terrain_cache_[offset];
            offset += window_width * window_height;
            render_shared_.terrain_tile_v_cache = &terrain_cache_[offset];
            offset += window_width * window_height;
            render_shared_.terrain_tile_i_cache = &terrain_cache_[offset];
            offset += window_width * window_height;
            render_shared_.terrain_tile_j_cache = &terrain_cache_[offset];
            render_shared_.camera_x = 0;
            render_shared_.camera_y = 0;

            tile_map_ptr_ = std::unique_ptr<TileMap>{nullptr};

            char buf[32];
            for(uint8_t i = 1; i <= 4; ++i) {
                const uint8_t capacity = (i < 4) ? 16 : 4;
                tiles_[i-1].reserve(capacity);
                for(uint8_t j = 0; j < capacity; ++j)
                {
                    if(j < 10) {
                        sprintf(buf, "terrain/tile%d-0%u.bmp", i, j);
                    } else {
                        sprintf(buf, "terrain/tile%d-%u.bmp", i, j);
                    }
                    auto[success, next_bmp] = Game::Resources::Graphics().read_pal_bmp_shared(buf);
                    if(success) {
                        tiles_[i-1].emplace_back(next_bmp);
                    }
                }
            }

            for(size_t i = 0; i < 3 * 256 * 256; i+= 3) {
                normal_map[i] = 0.0f;
                normal_map[i+1] = 0.0f;
                normal_map[i+2] = 1.0f;
            }

            for(size_t i = 0; i < 256 * 256; i+= 3) {
                lightness_map[i] = 255;
                fov_map[i] = 0;
                fov_map_shifted[i] = 0;
            }

            fov_sprite_.lock([&](auto dw, auto dh, auto rb, auto gb, auto bb, auto ab){
                for(size_t i = 0; i < dw*dh; ++i) {
                    rb[i] = 0x07;
                    gb[i] = 0x02;
                    bb[i] = 0x13;
                    ab[i] = 0;
                }
                screen_space_fov_ = ab;
            });

            auto [font_success, font] = Game::Resources::Graphics().read_font_16_shared("font2/font2.16", "font2/font2.dat");
            if(!font_success) {
                throw std::runtime_error("failed on loading font");
            }
            debug_font_ = font;
        }

        void Stage::load_level(uint8_t level_id) {
            for(size_t i = 0; i < 256 * 256; i+= 3) {
                fov_map[i] = 0;
            }

            char buffer[16];
            sprintf(buffer, "%u.alm", level_id);
            auto resource_header = Game::Resources::Scenario().get_resource(buffer);
            if(resource_header == nullptr) {
                LOG_ERROR("could not load resource " << buffer);
                return;
            }

            std::string bytes = resource_header->bytes();
            kaitai::kstream ks(bytes);
            rage_of_mages_1_alm_t alm{&ks};

            auto general_map_info = alm.general_map_info();

            max_camera_x_ = static_cast<uint32_t>((general_map_info->width() - 16) * 32 - (window_width_ - 160));
            max_camera_y_ = static_cast<uint32_t>((general_map_info->height() - 16) * 32 - window_height_);

            tile_map_ptr_.release();
            tile_map_ptr_ = std::make_unique<TileMap>(
                general_map_info->width(),
                general_map_info->height()
            );

            uint8_t tiles_id      = NO_ID;
            uint8_t height_map_id = NO_ID;
            uint8_t trigger_id    = NO_ID;
            uint8_t map_obj_id    = NO_ID;
            uint8_t fractions_id  = NO_ID;
            uint8_t units_id      = NO_ID;
            uint8_t structures_id = NO_ID;
            uint8_t sacks_id      = NO_ID;
            uint8_t effects_id    = NO_ID;

            LOG("READING SECTION HEADERS. SEARCHING CONCRETE SECTION LOCATIONS");
            for(uint8_t i = 0; i < alm.sections()->size(); ++i) {
                const rage_of_mages_1_alm_t::alm_section_t* section_info = alm.sections()->at(i);

                switch (section_info->header()->section_kind()) {
                    case rage_of_mages_1_alm_t::SECTION_KIND_E_TILES:
                        tiles_id = i;
                        break;
                    case rage_of_mages_1_alm_t::SECTION_KIND_E_HEIGHT_MAP:
                        height_map_id = i;
                        break;
                    case rage_of_mages_1_alm_t::SECTION_KIND_E_FRACTIONS:
                        fractions_id = i;
                        break;
                    case rage_of_mages_1_alm_t::SECTION_KIND_E_MAP_OBJECTS:
                        map_obj_id = i;
                        break;
                    case rage_of_mages_1_alm_t::SECTION_KIND_E_TRIGGERS:
                        trigger_id = i;
                        break;
                    case rage_of_mages_1_alm_t::SECTION_KIND_E_UNITS:
                        units_id = i;
                        break;
                    case rage_of_mages_1_alm_t::SECTION_KIND_E_STRUCTURES:
                        structures_id = i;
                        break;
                    case rage_of_mages_1_alm_t::SECTION_KIND_E_SACKS:
                        sacks_id = i;
                        break;
                    case rage_of_mages_1_alm_t::SECTION_KIND_E_EFFECTS:
                        effects_id = i;
                        break;
                    default: break;
                }
            }

            LOG("LOADING TILEMAP DATA");
            {
                if(tiles_id == NO_ID || height_map_id == NO_ID) {
                    LOG_ERROR("there was an error while retrieving tilemap data");
                    return;
                }

                const auto tiles_data =
                    dynamic_cast<rage_of_mages_1_alm_t::tiles_sec_t*>(
                        alm.sections()->at(tiles_id)->body()
                    );
                const auto height_map_data =
                    dynamic_cast<rage_of_mages_1_alm_t::height_map_sec_t*>(
                        alm.sections()->at(height_map_id)->body()
                    );

                if(tiles_data == nullptr || height_map_data == nullptr) {
                    LOG_ERROR("there was an error while retrieving tilemap data (dynamic cast)");
                    return;
                }

                const auto tiles = *(tiles_data->tiles());
                const auto height_map = *(height_map_data->heights());

                if(tiles.size() % 8 != 0) {
                    LOG_ERROR("hmm...");
                }

                size_t t_stride = general_map_info->width();
                size_t h_stride = general_map_info->width();

                size_t t_offset = 0;
                size_t h_offset = 0;

                for(uint16_t y = 0; y < general_map_info->height(); ++y) {
                    int16_t min_y = (static_cast<int16_t>(y) - 8) * 32;
                    int16_t max_y = min_y + 32;
                    for(uint16_t i = 0; i < general_map_info->width(); ++i) {
                        auto& next_tile = tile_map_ptr_->get_tile(i, y);
                        next_tile.tile_i = static_cast<uint8_t>(i);
                        next_tile.tile_j = static_cast<uint8_t>(y);

                        const auto tile = tiles[t_offset + i];
                        const auto height_tl = height_map[h_offset + i];
                        const auto height_tr = (i < general_map_info->width()-1)
                                ? height_map[h_offset + i + 1]
                                : height_tl;

                        const auto height_bl = (y < tile_map_ptr_->height()-1 )
                                ? height_map[h_offset + i + h_stride] :
                                height_tl;

                        const auto height_br =  (y < tile_map_ptr_->height()-1 )
                                ? ((i < general_map_info->width()-1)
                                ? height_map[h_offset + i + h_stride + 1]
                                : height_bl) : height_tl;

                        next_tile.tile_id = tile->tile_id();
                        auto& corners = next_tile.corners;

                        corners.top_left_height = height_tl;
                        corners.top_right_height = height_tr;
                        corners.bottom_left_height = height_bl;
                        corners.bottom_right_height = height_br;
                        next_tile.min_y = std::min(min_y - height_tl, min_y - height_tr);
                        next_tile.max_y = std::max(max_y - height_bl, max_y - height_br);
                    }
                    t_offset += t_stride;
                    h_offset += h_stride;
                }

                LOG("CALC STATIC LIGHTING");
                {
                    for(uint8_t j = 1; j < general_map_info->height() - 1; ++j) {
                        size_t stride = (j * 256 + 1) * 3;
                        for(uint8_t i = 1; i < general_map_info->width() - 1; ++i) {

                            float x = height_map[h_stride * j + i - 1] - height_map[h_stride * j + i]; /*f(p.x-eps,p.z) - f(p.x+eps,p.z)*/
                            float y = 16.0f * 2; /*2.0f*eps*/
                            float z = height_map[h_stride * j + i - h_stride] - height_map[h_stride * j + i]; /*f(p.x,p.z-eps) - f(p.x,p.z+eps)*/
                            float d = std::sqrtf(x*x + y*y + z*z);

                            x /= d;
                            y /= -d;
                            z /= d;

                            normal_map[stride++] = x;
                            normal_map[stride++] = y;
                            normal_map[stride++] = z;
                        }
                    }
                    recalc_lighting();
                }
            }

            LOG("SEARCHING FOR START LOCATION");
            {
                if(trigger_id == NO_ID) {
                    LOG_ERROR("there was an error while retrieving trigger data");
                    return;
                }

                const auto trigger_data =
                    dynamic_cast<rage_of_mages_1_alm_t::triggers_sec_t*>(
                        alm.sections()->at(trigger_id)->body()
                    );

                if(trigger_data == nullptr) {
                    LOG_ERROR("there was an error while retrieving trigger data (dynamic cast)");
                    return;
                }

                auto instances = *(trigger_data->instances());

                for(uint16_t i = 0; i < instances.size(); ++i) {
                    const auto current_instance = instances[i];
                    if(current_instance->type() == rage_of_mages_1_alm_t::INSTANCE_TYPE_START_HERE) {
                        LOG("FOUND DROP LOCATION INSTANCE!");
                        auto drop_x = static_cast<int32_t>(current_instance->argument_values()->at(0));
                        auto drop_y = static_cast<int32_t>(current_instance->argument_values()->at(1));

                        for(int32_t j = drop_y - 16; j < drop_y + 16; ++j) {
                            for(int32_t i = drop_x - 16; i < drop_x + 16; ++i) {
                                if(j < 0 || j > 255) {
                                    continue;
                                }
                                if(i < 0 || i > 255) {
                                    continue;
                                }
                                const auto offs = i + j * 256;

                                fov_map[offs] =
                                    std::max(
                                         std::abs(i - drop_x),
                                         std::abs(j - drop_y)
                                    ) <= 6 ? 255 : 196;
                            }
                        }

                        for(int32_t j = drop_y - 16; j < drop_y + 16; ++j) {
                            for(int32_t i = drop_x - 16; i < drop_x + 16; ++i) {
                                if(j < 1 || j >= 255) {
                                    continue;
                                }
                                if(i < 1 || i >= 255) {
                                    continue;
                                }
                                const auto offs = i + j * 256;

                                fov_map_shifted[offs] =
                                    (fov_map[offs] + fov_map[offs + 1] + fov_map[offs - 256] + fov_map[offs - 255]) / 4;
                            }
                        }


                        int32_t desired_x = (drop_x * 64 - window_width_) / 2;
                        int32_t desired_y = (drop_y * 64 - window_height_) / 2;

                        render_shared_.camera_x =
                            desired_x > static_cast<int32_t>(max_camera_x_) ? max_camera_x_ :
                            desired_x < 0 ? 0 :
                            static_cast<uint32_t>(desired_x);

                        render_shared_.camera_y =
                            desired_y > static_cast<int32_t>(max_camera_y_) ? max_camera_y_ :
                            desired_y < 0 ? 0 :
                            static_cast<uint32_t>(desired_y);

                        break;
                    }
                }
            }

            update_scrolling();

            LOG("LOADING MAP OBJECTS");
            {
                try {
                    const auto& map_object_meta = Game::Meta::MapObjects();
                    const auto& obj_info = map_object_meta.info();
                    const auto& obj_sprites = map_object_meta.sprites();

                    if(map_obj_id == NO_ID) {
                        LOG_ERROR("there was an error while retrieving map object data");
                        return;
                    }

                    const auto obj_data =
                        dynamic_cast<rage_of_mages_1_alm_t::map_objects_sec_t*>(
                            alm.sections()->at(map_obj_id)->body()
                        );

                    if(obj_data == nullptr) {
                        LOG_ERROR("there was an error while retrieving map object data (dynamic cast)");
                        return;
                    }

                    auto count = obj_data->objects()->size();

                    map_objects_.clear();

                    for(size_t i = 0; i < count; ++i) {
                        auto obj_id = obj_data->objects()->at(i);
                        if(obj_id == 0) continue;

                        int32_t real_id = -1;
                        for(size_t j = 0; j < obj_info.size(); ++j) {
                            if(obj_info[j].id == obj_id-1) {
                                real_id = static_cast<int32_t>(j);
                                break;
                            }
                        }
                        if(real_id == -1) {
                            continue;
                        }

                        auto x = i % tile_map_ptr_->width();
                        auto y = i / tile_map_ptr_->width();

                        auto xx = tile_map_ptr_->get_x_at_tile(x, y, 16, 16);
                        auto yy = tile_map_ptr_->get_y_at_tile(x, y, 16, 16);

                        LOG_ASSERT(static_cast<size_t>(real_id) < obj_info.size())

                        const auto& meta_entry = obj_info[static_cast<size_t>(real_id)];

                        int32_t cur_phase;
                        int32_t phase_time;

                        if(meta_entry.anim_frames.size() >= 1 && meta_entry.anim_times.size() >= 1) {
                            cur_phase = static_cast<int32_t>(static_cast<uint16_t>(rand()) % meta_entry.anim_frames.size());
                            phase_time = meta_entry.anim_times[static_cast<uint16_t>(cur_phase)];
                        } else {
                            cur_phase = 0;
                            phase_time = -1;
                        }

                        auto sprite = const_cast<std::shared_ptr<Sprite256>&>(obj_sprites[static_cast<size_t>(meta_entry.file_id)]);

                        map_objects_.emplace_back(
                            xx,
                            yy,
                            y,
                            phase_time,
                            cur_phase,
                            real_id,
                            meta_entry.dead_id == -1 ? object_state::dead : object_state::alive,
                            sprite
                        );
                    }
                } catch (const std::exception& ex) {
                    LOG_ERROR(ex.what());
                }
            }

            LOG("LOADING STRUCTURES");
            {
                try {
                    const auto& structure_meta = Game::Meta::Structures();
                    const auto& struct_info = structure_meta.info();
                    const auto& struct_sprites = structure_meta.sprites();

                    if(structures_id == NO_ID) {
                        LOG_ERROR("there was an error while retrieving structure data");
                        return;
                    }

                    const auto structure_data =
                        dynamic_cast<rage_of_mages_1_alm_t::structures_sec_t*>(
                            alm.sections()->at(structures_id)->body()
                        );

                    if(structure_data == nullptr) {
                        LOG_ERROR("there was an error while retrieving structure data (dynamic cast)");
                        return;
                    }

                    const auto count = structure_data->structures()->size();
                    bridge_info_entries_.clear();
                    structures_.clear();
                    structures_.reserve(count);

                    for(size_t i = 0; i < count; ++i) {
                        auto struct_entry = structure_data->structures()->at(i);
                        uint16_t brindge_info_id = NO_BRIDGE;

                        if(!struct_entry->_is_null_bridge_details()) {
                            brindge_info_id = static_cast<uint16_t>(bridge_info_entries_.size());
                            bridge_info_entries_.push_back(
                                std::make_tuple(
                                    static_cast<uint8_t>(struct_entry->bridge_details()->width()),
                                    static_cast<uint8_t>(struct_entry->bridge_details()->height())
                                )
                            );
                        }

                        int32_t real_id = -1;
                        for(size_t j = 0; j < struct_info.size(); ++j) {
                            if(static_cast<uint32_t>(struct_info[j].id) == struct_entry->type_id()) {
                                if(struct_entry->type_id() == 48) {
                                    LOG("TELEPORT FOUND");
                                }
                                real_id = static_cast<int32_t>(j);
                                break;
                            }
                        }
                        if(real_id == -1) {
                            continue;
                        }

                        auto x = static_cast<size_t>(struct_entry->x_coord() / 0x100);
                        auto y = static_cast<size_t>(struct_entry->y_coord() / 0x100);

                        auto u = static_cast<uint8_t>((struct_entry->x_coord() & 0xFF) / 8);
                        auto v = static_cast<uint8_t>((struct_entry->y_coord() & 0xFF) / 8);

                        auto xx = tile_map_ptr_->get_x_at_tile(x, y, u, v);
                        auto yy = tile_map_ptr_->get_y_at_tile(x, y, u, v);

                        const auto& meta_entry = struct_info[static_cast<size_t>(real_id)];

                        if(meta_entry.full_height > meta_entry.tile_height) {
                            yy -= 32 * (meta_entry.full_height - meta_entry.tile_height);
                        }

                        int32_t phase_time;

                        if(meta_entry.anim_frames.size() >= 1 && meta_entry.anim_times.size() >= 1) {
                            phase_time = meta_entry.anim_times[0];
                        } else {
                            phase_time = -1;
                        }

                        auto sprite = const_cast<std::shared_ptr<Sprite256>&>(struct_sprites[static_cast<size_t>(real_id)]);

                        structures_.emplace_back(
                            xx,
                            yy,
                            y,
                            phase_time,
                            0,
                            real_id,
                            brindge_info_id,
                            static_cast<uint16_t>(struct_entry->fraction_id()),
                            static_cast<uint16_t>(struct_entry->health()),
                            sprite
                        );
                    }

                } catch (const std::exception& ex) {
                    LOG_ERROR(ex.what());
                }
            }

            LOG("TODO: LOADING FRACTIONS");
            {

            }

            LOG("TODO: LOADING UNITS");
            {

            }

            LOG("TODO: LOADING SACKS");
            {

            }

            LOG("TODO: LOADING EFFECTS");
            {

            }

            LOG("TODO: LOADING TRIGGERS");
            {

            }
        }

        Stage::~Stage() {
            delete [] terrain_cache_;
        }

        void Stage::recalc_lighting(){
            float sun_angle = 3.141615f * (shadow_offset_) / 512.0f - 3.141615f * 0.5f; //-general_map_info->negative_sun_angle();

            float sun_x = -std::cos(sun_angle);
            float sun_y = -0.8f;
            float sun_z = -std::sin(sun_angle);

            float d = std::sqrtf(sun_x*sun_x + sun_y*sun_y + sun_z*sun_z);
            sun_x /= d;
            sun_y /= d;
            sun_z /= d;

            for(uint8_t j = 1; j < tile_map_ptr_->height() - 1; ++j) {
                size_t stride = (j * 256 + 1) * 3;
                for(uint8_t i = 1; i < tile_map_ptr_->width() - 1; ++i) {
                    float x = normal_map[stride++];
                    float y = normal_map[stride++];
                    float z = normal_map[stride++];

                    float lambertian = std::max(0.0f, (sun_x * x + sun_y * y + sun_z * z));

                    lightness_map[256 * j + i] = static_cast<uint8_t>(lambertian * 7.5f + 7.0f);
                }
            }
        }

        void Stage::update_fog_of_war_rendition() {
            static bool marked[256*256];
            for(uint8_t j = 1; j < 255; ++j) {
                for(uint8_t i = 1; i < 255; ++i) {
                    const auto dj = j - tile_selection_y;
                    const auto di = i - tile_selection_x;
                    const auto offs = i + j * 256;
                    marked[offs] = false;

                    if((di*di + dj * dj) <= 48) {
                        fov_map[offs] = 255;
                    } else if(fov_map[i + j * 256] == 255) {
                        fov_map[offs] = 196;
                    }
                }
            }
            std::queue<uint8_t> i_queue;
            std::queue<uint8_t> j_queue;
            for(uint8_t j = 1; j < 255; ++j) {
                for(uint8_t i = 1; i < 255; ++i) {
                    const auto offs = i + j * 256;
                    uint8_t new_fov_shifted = (fov_map[offs] + fov_map[offs - 1] + fov_map[offs - 257] + fov_map[offs - 256]) / 4;

                    if(fov_map_shifted[offs] != new_fov_shifted) {
                        fov_map_shifted[offs] = new_fov_shifted;
                        if(i < tile_map_ptr_->width() && j < tile_map_ptr_->height()) {
                            i_queue.push(i);
                            j_queue.push(j);
                        }
                    }
                }
            }
            while(!i_queue.empty() && !j_queue.empty()) {
                auto i = i_queue.front();
                auto j = j_queue.front();
                i_queue.pop();
                j_queue.pop();
                if(!marked[i + j * 256]) {
                    update_tile(i, j);
                    marked[i + j * 256] = true;
                }
                if(!marked[i + j * 256 + 1]) {
                    update_tile(i + 1, j);
                    marked[i + j * 256 + 1] = true;
                }
                if(!marked[i + j * 256 - 1]) {
                    update_tile(i - 1, j);
                    marked[i + j * 256 - 1] = true;
                }
                if(!marked[i + j * 256 - 257]) {
                    update_tile(i - 1, j - 1);
                    marked[i + j * 256 - 257] = true;
                }
                if(!marked[i + j * 256 - 256]) {
                    update_tile(i, j - 1);
                    marked[i + j * 256 - 256] = true;
                }
                if(!marked[i + j * 256 - 255]) {
                    update_tile(i + 1, j - 1);
                    marked[i + j * 256 - 255] = true;
                }
                if(!marked[i + j * 256 + 255]) {
                    update_tile(i - 1, j + 1);
                    marked[i + j * 256 + 255] = true;
                }
                if(!marked[i + j * 256 + 256]) {
                    update_tile(i, j + 1);
                    marked[i + j * 256 + 256] = true;
                }
                if(!marked[i + j * 256 + 257]) {
                    update_tile(i + 1, j + 1);
                    marked[i + j * 256 + 257] = true;
                }
            }
        }

        void Stage::update(const MouseState &mouse_state) {
            //process_scrolling
            {
                bool is_scrolled = false;
                if(mouse_state.mouse_x < 16 && render_shared_.camera_x >= SCROLL_SPEED) {
                    is_scrolled = true;
                    render_shared_.camera_x -= SCROLL_SPEED;
                    const size_t size = window_width_-SCROLL_SPEED;
                    tiles_sprite_.lock([&](auto tsw, auto tsh, auto rb, auto gb, auto bb)
                    {
                        for(int j = 0; j < tsh; ++j)
                        {
                            const auto stride = j * tsw;
                            memmove(&rb[stride+SCROLL_SPEED], &rb[stride], size);
                            memmove(&gb[stride+SCROLL_SPEED], &gb[stride], size);
                            memmove(&bb[stride+SCROLL_SPEED], &bb[stride], size);
                            memmove(&screen_space_fov_[stride+SCROLL_SPEED], &screen_space_fov_[stride], size);
                        }
                    });
                    for(int j = 0; j < window_height_ * 6; ++j) {
                        const auto stride = j * window_width_;
                        memmove(&terrain_cache_[stride+SCROLL_SPEED], &terrain_cache_[stride], size);
                    }
                    update_scrolling(0, SCROLL_SPEED, 0, window_height_);
                } else if(mouse_state.mouse_x >= (window_width_ - 16) && render_shared_.camera_x < (max_camera_x_ - SCROLL_SPEED - 1)) {
                    is_scrolled = true;
                    render_shared_.camera_x += SCROLL_SPEED;
                    const size_t size = window_width_-SCROLL_SPEED;
                    tiles_sprite_.lock([&](auto tsw, auto tsh, auto rb, auto gb, auto bb)
                    {
                        for(int j = 0; j < tsh; ++j)
                        {
                            const auto stride = j * tsw;
                            memmove(&rb[stride], &rb[stride+SCROLL_SPEED], size);
                            memmove(&gb[stride], &gb[stride+SCROLL_SPEED], size);
                            memmove(&bb[stride], &bb[stride+SCROLL_SPEED], size);
                            memmove(&screen_space_fov_[stride], &screen_space_fov_[stride+SCROLL_SPEED], size);
                        }
                    });
                    for(int j = 0; j < window_height_ * 6; ++j) {
                        const auto stride = j * window_width_;
                        memmove(&terrain_cache_[stride], &terrain_cache_[stride+SCROLL_SPEED], size);
                    }
                    update_scrolling(window_width_ - SCROLL_SPEED, window_width_, 0, window_height_);
                }
                if(mouse_state.mouse_y < 16 && render_shared_.camera_y >= SCROLL_SPEED) {
                    is_scrolled = true;
                    render_shared_.camera_y -= SCROLL_SPEED;
                    const size_t offset = window_width_*SCROLL_SPEED;
                    size_t base_offset = 0;
                    size_t size = window_width_*(window_height_-SCROLL_SPEED);
                    tiles_sprite_.lock([&](auto tsw, auto tsh, auto rb, auto gb, auto bb)
                    {
                        memmove(&rb[offset], &rb[0], size);
                        memmove(&gb[offset], &gb[0], size);
                        memmove(&bb[offset], &bb[0], size);
                        memmove(&screen_space_fov_[offset], &screen_space_fov_[0], size);
                    });
                    for(uint16_t i = 0; i < 6; ++i){
                        memmove(&terrain_cache_[base_offset+offset], &terrain_cache_[base_offset], size);
                        base_offset += window_width_*window_height_;
                    }
                    update_scrolling(0, window_width_, 0, SCROLL_SPEED);
                } else if(mouse_state.mouse_y >= (window_height_ - 16) && render_shared_.camera_y < (max_camera_y_ - SCROLL_SPEED - 1)) {
                    is_scrolled = true;
                    render_shared_.camera_y += SCROLL_SPEED;
                    const size_t offset = window_width_*SCROLL_SPEED;
                    size_t base_offset = 0;
                    size_t size = window_width_*(window_height_-SCROLL_SPEED);
                    tiles_sprite_.lock([&](auto tsw, auto tsh, auto rb, auto gb, auto bb)
                    {
                        memmove(&rb[0], &rb[offset], size);
                        memmove(&gb[0], &gb[offset], size);
                        memmove(&bb[0], &bb[offset], size);
                        memmove(&screen_space_fov_[0], &screen_space_fov_[offset], size);
                    });
                    for(uint16_t i = 0; i < 6; ++i){
                        memmove(&terrain_cache_[base_offset], &terrain_cache_[base_offset+offset], size);
                        base_offset += window_width_*window_height_;
                    }
                    update_scrolling(0, window_width_, window_height_-SCROLL_SPEED, window_height_);
                }
            }

            //update fov
            {
                auto tile_offs = mouse_state.mouse_x + mouse_state.mouse_y * window_width_;
                auto tile_y_selected = render_shared_.terrain_tile_j_cache[tile_offs];
                auto tile_x_selected = render_shared_.terrain_tile_i_cache[tile_offs];
                if(tile_selection_x != tile_x_selected || tile_selection_y != tile_y_selected) {
                    tile_selection_x = tile_x_selected;
                    tile_selection_y = tile_y_selected;
                    update_fog_of_war_rendition();
                }
            }

            //update_world
            {
                //shadow_offset_ = ((shadow_offset_ + 129) % 256) - 128;
                recalc_lighting();
                const uint8_t WATER_SCROLLING_TICKS = 4;
                ++water_offset_;
                if(water_offset_ % WATER_SCROLLING_TICKS == 0) {
                    update_water_tiles();
                }
                for(size_t i = 0; i < map_objects_.size(); ++i) {
                    if(map_objects_[i].phase_ticks_remain < 0) continue;
                    if(map_objects_[i].phase_ticks_remain == 1) {
                        const auto& meta = Game::Meta::MapObjects().info()[static_cast<size_t>(map_objects_[i].meta_id)];
                        map_objects_[i].current_phase = (map_objects_[i].current_phase + 1) % meta.phases_count;
                        map_objects_[i].phase_ticks_remain = meta.anim_times[static_cast<size_t>(map_objects_[i].current_phase)];
                        continue;
                    }
                    --map_objects_[i].phase_ticks_remain;
                }
                for(size_t i = 0; i < structures_.size(); ++i) {
                    if(structures_[i].phase_ticks_remain < 0) continue;
                    if(structures_[i].phase_ticks_remain == 1) {
                        const auto& meta = Game::Meta::Structures().info()[static_cast<size_t>(structures_[i].meta_id)];
                        if(meta.phases_count == -1 || meta.anim_frames.size() == 0) continue;
                        ++structures_[i].current_phase;
                        if(static_cast<uint16_t>(structures_[i].current_phase) >= meta.anim_frames.size()){
                            structures_[i].current_phase = 0;
                        }
                        structures_[i].phase_ticks_remain = meta.anim_times[static_cast<size_t>(structures_[i].current_phase)];
                        continue;
                    }
                    --structures_[i].phase_ticks_remain;
                }
            }



            //todo : game object selection etc here

        }

        template<typename FF>
        inline void brezenham(int32_t x0, int32_t y0, int32_t x1, int32_t y1, FF&& plot_func) {
            if(y0 == y1) {
                if(x1 >= x0) {
                    for(int32_t x = x0; x < x1; ++x) {
                        plot_func(x, y0);
                    }
                } else {
                    for(int32_t x = x1; x < x0; ++x) {
                        plot_func(x, y0);
                    }
                }
                return;
            }

            if(x0 == x1) {
                if(y1 >= y0) {
                    for(int32_t y = y0; y < y1; ++y) {
                        plot_func(x0, y);
                    }
                } else {
                    for(int32_t y = y1; y < y0; ++y) {
                        plot_func(x0, y);
                    }
                }
                return;
            }

            const auto dy_abs = std::abs(y1 - y0);
            const auto dx_abs = std::abs(x1 - x0);
            const auto dx2 = 2 * dx_abs;
            const auto dy2 = 2 * dy_abs;

            if(dx_abs >= dy_abs) {
                if(x0 > x1) {
                    auto buf = x0; x0 = x1; x1 = buf;
                    buf = y0; y0 = y1; y1 = buf;
                }
                const int8_t sign = (y1 > y0) ? 1 : -1;
                int32_t D = dy2 - dx_abs;
                int32_t y = y0;
                for(int32_t x = x0; x <= x1; ++x) {
                    plot_func(x, y);
                    if(D > 0) {
                        D -= dx2;
                        y += sign;
                    }
                    D += dy2;
                }

            } else {
                if(y0 > y1) {
                    auto buf = y0; y0 = y1; y1 = buf;
                    buf = x0; x0 = x1; x1 = buf;
                }
                const int8_t sign = (x1 > x0) ? 1 : -1;
                int32_t D = dx2 - dy_abs;
                int32_t x = x0;
                for(int32_t y = y0; y <= y1; ++y) {
                    plot_func(x, y);
                    if(D > 0) {
                        D -= dy2;
                        x += sign;
                    }
                    D += dx2;
                }
            }
        }

        void Stage::render(SOASpriteRGB &background_sprite) {
            draw_tiles(background_sprite);

            //draw_wireframe(background_sprite);

            send_objects_to_render();
            send_structures_to_render();

            while (!render_queue_.empty()) {
                auto[priority, id, kind] = render_queue_.top();
                render_queue_.pop();
                switch(kind) {
                    case renderer_kind::object:{
                        auto& obj = map_objects_[id];
                        const auto& meta = Game::Meta::MapObjects().info()[static_cast<size_t>(obj.meta_id)];

                        uint16_t idx = meta.index != -1 ? static_cast<uint16_t>(meta.index) : 0;

                        auto obj_x = obj.coord_x - static_cast<int32_t>(render_shared_.camera_x);
                        auto obj_y = obj.coord_y - static_cast<int32_t>(render_shared_.camera_y);

                        uint16_t real_idx = (static_cast<uint16_t>(obj.current_phase) + idx) % meta.phases_count;

                        auto frame = real_idx < meta.anim_frames.size() ? meta.anim_frames[real_idx] : idx;

                        obj.sprite->blit_on_sprite_centered(
                            background_sprite,
                            obj_x,
                            obj_y,
                            static_cast<uint16_t>(frame),
                            meta.center_x, meta.center_y,
                            meta.fixed_w, meta.fixed_h
                        );
                    }
                        break;
                    case renderer_kind::unit:
                            //TODO: render units
                        break;
                    case renderer_kind::structure:{
                        auto& struct_entry = structures_[id];
                        const auto& meta = Game::Meta::Structures().info()[static_cast<size_t>(struct_entry.meta_id)];

                        auto obj_x = struct_entry.coord_x - static_cast<int32_t>(render_shared_.camera_x);
                        auto obj_y = struct_entry.coord_y - static_cast<int32_t>(render_shared_.camera_y);

                        uint16_t cur_frame = static_cast<uint16_t>(meta.anim_frames.size() > 0
                            ? meta.anim_frames[static_cast<uint16_t>(struct_entry.current_phase)]
                            : 0);

                        auto full_size = meta.tile_width * meta.full_height;

                        uint16_t offs = 0;
                        uint16_t help_stride = cur_frame == 0 ? 0 : meta.anim_mask_stride * (cur_frame - 1) - 1;

                        auto h = std::max(meta.tile_height, 1);
                        auto w = std::max(meta.tile_width, 1);
                        bool is_bridge = false;

                        if(struct_entry.bridge_info_id != NO_BRIDGE) {
                            auto[bw, bh] = bridge_info_entries_[struct_entry.bridge_info_id];
                            is_bridge = true;
                            w = bw;
                            h = bh;
                        }

                        for(int8_t iy = 0; iy < h; ++iy){
                            for(int8_t ix = 0; ix < w; ++ix) {
                                uint16_t real_frame = offs;
                                if(is_bridge) {
                                    auto bridge_x = (ix == 0) ? LEFT_BORDER
                                        : (ix == w-1) ? RIGHT_BORDER
                                        : HORIZONTAL_CENTER;

                                    auto bridge_y = (iy == 0) ? TOP_BORDER
                                        : (iy == h-1) ? BOTTOM_BORDER
                                        : VERTICAL_CENTER;

                                    real_frame = bridge_y * BRIGDE_STRIDE + bridge_x;
                                } else if(struct_entry.health == 0) {
                                    real_frame = static_cast<uint16_t>(struct_entry.sprite->frame_count() - full_size + real_frame);
                                } else if(cur_frame > 0) {
                                    if(full_size == 1) {
                                        real_frame = cur_frame;
                                    } else if(meta.anim_mask[offs] == '+') {
                                        real_frame = static_cast<uint16_t>(
                                            full_size +
                                            help_stride +
                                            meta.anim_mask_shifts[offs]
                                        );
                                    }
                                }
                                ++offs;
                                struct_entry.sprite->blit_on_sprite_centered(
                                    background_sprite,
                                    obj_x + ix * 32,
                                    obj_y + iy * 32,
                                    real_frame,
                                    127, 127,
                                    256, 256);
                            }
                        }
                    }
                        break;
                    case renderer_kind::structure_bottom:{
                        auto& struct_entry = structures_[id];
                        const auto& meta = Game::Meta::Structures().info()[static_cast<size_t>(struct_entry.meta_id)];

                        auto obj_x = struct_entry.coord_x - static_cast<int32_t>(render_shared_.camera_x);
                        auto obj_y = struct_entry.coord_y - static_cast<int32_t>(render_shared_.camera_y);

                        uint16_t cur_frame = static_cast<uint16_t>(meta.anim_frames.size() > 0
                            ? meta.anim_frames[static_cast<uint16_t>(struct_entry.current_phase)]
                            : 0);

                        auto full_size = meta.tile_width * meta.full_height;

                        auto h = std::max(meta.full_height, 1);
                        auto w = std::max(meta.tile_width, 1);

                        if(struct_entry.bridge_info_id != NO_BRIDGE) {
                            break;
                        }

                        uint8_t offs = static_cast<uint8_t>(meta.tile_width*meta.tile_height);
                        uint16_t help_stride = cur_frame == 0 ? 0 : meta.anim_mask_stride * (cur_frame - 1) - 1;

                        for(int8_t iy = static_cast<int8_t>(meta.tile_height); iy < h; ++iy){
                            for(int8_t ix = 0; ix < w; ++ix) {
                                uint16_t real_frame = offs;
                                if(struct_entry.health == 0) {
                                    real_frame = static_cast<uint16_t>(struct_entry.sprite->frame_count() - full_size + real_frame);
                                } else if(cur_frame > 0) {
                                    if(full_size == 1) {
                                        real_frame = cur_frame;
                                    } else if(meta.anim_mask[offs] == '+') {
                                        real_frame = static_cast<uint16_t>(
                                            full_size +
                                            help_stride +
                                            meta.anim_mask_shifts[offs]
                                        );
                                    }
                                }
                                ++offs;
                                struct_entry.sprite->blit_on_sprite_centered(
                                    background_sprite,
                                    obj_x + ix * 32,
                                    obj_y + iy * 32,
                                    real_frame,
                                    127, 127,
                                    256, 256);
                            }
                        }
                    }
                        break;
                    case renderer_kind::object_shadow:{
                        auto& obj = map_objects_[id];
                        const auto& meta = Game::Meta::MapObjects().info()[static_cast<size_t>(obj.meta_id)];

                        uint16_t idx = meta.index != -1 ? static_cast<uint16_t>(meta.index) : 0;

                        auto obj_x = obj.coord_x - static_cast<int32_t>(render_shared_.camera_x);
                        auto obj_y = obj.coord_y - static_cast<int32_t>(render_shared_.camera_y);

                        uint16_t real_idx = (static_cast<uint16_t>(obj.current_phase) + idx) % meta.phases_count;

                        auto frame = real_idx < meta.anim_frames.size() ? meta.anim_frames[real_idx] : idx;

                        obj.sprite->blit_shadow_centered(
                            background_sprite,
                            obj_x,
                            obj_y,
                            static_cast<uint16_t>(frame),
                            meta.center_x, meta.center_y,
                            meta.fixed_w, meta.fixed_h,
                            static_cast<uint16_t>(meta.center_y),
                            static_cast<uint8_t>(meta.fixed_h),
                            shadow_offset_
                        );
                    }
                        break;
                    case renderer_kind::unit_shadow:{
                            //TODO: render unit shadows
                        }
                        break;
                    case renderer_kind::structure_shadow:{auto& struct_entry = structures_[id];
                            const auto& meta = Game::Meta::Structures().info()[static_cast<size_t>(struct_entry.meta_id)];

                            auto obj_x = struct_entry.coord_x - static_cast<int32_t>(render_shared_.camera_x);
                            auto obj_y = struct_entry.coord_y - static_cast<int32_t>(render_shared_.camera_y);

                            uint16_t cur_frame = static_cast<uint16_t>(meta.anim_frames.size() > 0
                                ? meta.anim_frames[static_cast<uint16_t>(struct_entry.current_phase)]
                                : 0);

                            auto full_size = meta.tile_width * meta.full_height;

                            uint16_t offs = 0;
                            uint16_t help_stride = cur_frame == 0 ? 0 : meta.anim_mask_stride * (cur_frame - 1) - 1;

                            if(meta.shadow_y > 256) {
                                break;
                            }

                            auto h = std::max(meta.tile_height, 1);
                            auto w = std::max(meta.tile_width, 1);
                            bool is_bridge = false;

                            if(struct_entry.bridge_info_id != NO_BRIDGE) {
                                auto[bw, bh] = bridge_info_entries_[struct_entry.bridge_info_id];
                                is_bridge = true;
                                w = bw;
                                h = bh;
                            }

                            for(int8_t iy = 0; iy < h; ++iy){
                                for(int8_t ix = 0; ix < w; ++ix) {
                                    uint16_t real_frame = offs;
                                    if(is_bridge) {

                                        auto bridge_x = (ix == 0) ? LEFT_BORDER
                                            : (ix == w-1) ? RIGHT_BORDER
                                            : HORIZONTAL_CENTER;

                                        auto bridge_y = (iy == 0) ? TOP_BORDER
                                            : (iy == h-1) ? BOTTOM_BORDER
                                            : VERTICAL_CENTER;

                                        real_frame = bridge_y * BRIGDE_STRIDE + bridge_x;
                                    } else if(struct_entry.health == 0) {
                                        real_frame = static_cast<uint16_t>(struct_entry.sprite->frame_count() - full_size + real_frame);
                                    } else if(cur_frame > 0) {
                                        if(full_size == 1) {
                                            real_frame = cur_frame;
                                        } else if(meta.anim_mask[offs] == '+') {
                                            real_frame = static_cast<uint16_t>(
                                                full_size +
                                                help_stride +
                                                meta.anim_mask_shifts[offs]
                                            );
                                        }
                                    }
                                    ++offs;

                                    auto lol = (shadow_offset_ * 32 * iy) / 256;

                                    struct_entry.sprite->blit_shadow_centered(
                                        background_sprite,
                                        obj_x + ix * 32 - lol,
                                        obj_y + iy * 32,
                                        real_frame,
                                        127, 127,
                                        256, 256,
                                        static_cast<uint16_t>(32 * meta.full_height), 32,
                                        shadow_offset_);
                                }
                            }
                        }
                            break;
                    case renderer_kind::structure_bottom_shadow:{auto& struct_entry = structures_[id];
                        const auto& meta = Game::Meta::Structures().info()[static_cast<size_t>(struct_entry.meta_id)];

                        auto obj_x = struct_entry.coord_x - static_cast<int32_t>(render_shared_.camera_x);
                        auto obj_y = struct_entry.coord_y - static_cast<int32_t>(render_shared_.camera_y);

                        uint16_t cur_frame = static_cast<uint16_t>(meta.anim_frames.size() > 0
                            ? meta.anim_frames[static_cast<uint16_t>(struct_entry.current_phase)]
                            : 0);

                        auto full_size = meta.tile_width * meta.full_height;

                        if(meta.shadow_y > 256) {
                            break;
                        }

                        uint8_t offs = static_cast<uint8_t>(meta.tile_width*meta.tile_height);
                        uint16_t help_stride = cur_frame == 0 ? 0 : meta.anim_mask_stride * (cur_frame - 1) - 1;
                        for(int32_t iy = meta.tile_height; iy < meta.full_height; ++iy){
                            for(int8_t ix = 0; ix < std::max(meta.tile_width, 1); ++ix) {
                                uint16_t real_frame = offs;
                                if(struct_entry.bridge_info_id != NO_BRIDGE) {
                                    auto[bw, bh] = bridge_info_entries_[struct_entry.bridge_info_id];

                                    auto bridge_x = (ix == 0) ? LEFT_BORDER
                                        : (ix == bw-1) ? RIGHT_BORDER
                                        : HORIZONTAL_CENTER;
                                    auto bridge_y = (iy == 0) ? TOP_BORDER
                                        : (iy == bh-1) ? BOTTOM_BORDER
                                        : VERTICAL_CENTER;

                                    real_frame = bridge_y * BRIGDE_STRIDE + bridge_x;
                                } else if(struct_entry.health == 0) {
                                    real_frame = static_cast<uint16_t>(struct_entry.sprite->frame_count() - full_size + real_frame);
                                } else if(cur_frame > 0) {
                                    if(full_size == 1) {
                                        real_frame = cur_frame;
                                    } else if(meta.anim_mask[offs] == '+') {
                                        real_frame = static_cast<uint16_t>(
                                            full_size +
                                            help_stride +
                                            meta.anim_mask_shifts[offs]
                                        );
                                    }
                                }
                                ++offs;

                                auto lol = (shadow_offset_ * 32 * iy) / 256;

                                struct_entry.sprite->blit_shadow_centered(
                                    background_sprite,
                                    obj_x + ix * 32 - lol,
                                    obj_y + iy * 32,
                                    real_frame,
                                    127, 127,
                                    256, 256,
                                    static_cast<uint16_t>(32 * meta.full_height), 32,
                                    shadow_offset_);
                            }
                        }
                    }
                        break;
                }
            }
//            auto start = std::chrono::high_resolution_clock::now();
            fov_sprite_.blit_on_sprite(background_sprite, 0, 0);
//            auto end = std::chrono::high_resolution_clock::now();
//            std::chrono::duration<double, std::milli> elapsed = end-start;
//            LOG("draw fog: " << elapsed.count() << " ms.");
        }

        void Stage::on_enter() {

        }

        void Stage::send_objects_to_render() {
            //TODO: do this smarter with spatial partition
            for(size_t i = 0; i < map_objects_.size(); ++i) {
                const auto& obj = map_objects_[i];
                //we sort on depth, but additionally on obj.meta_id to "batch" similar sprites in a row together
                //we should do this coherently for all types of renderers so they all nicely sort together
                //TODO: check if this is a better way to make a priority or may be there is a better solution exists

                auto tr_x = (obj.coord_x - static_cast<int32_t>(render_shared_.camera_x)) / 32;
                auto tr_y = (obj.coord_y - static_cast<int32_t>(render_shared_.camera_y)) / 32;
                if(tr_y >= 2) tr_y -= 2;

                if(tr_x < 0 || tr_x > window_width_ / 32) continue;
                if(tr_y < 0 || tr_y > window_height_ / 32) continue;

                size_t priority = static_cast<size_t>(obj.depth * 0x200000 + obj.meta_id * 0x100 + 0x10);
                render_queue_.push(std::make_tuple(priority, i, renderer_kind::object_shadow));
                render_queue_.push(std::make_tuple(priority + static_cast<uint8_t>(tr_x), i, renderer_kind::object));
            }
        }

        void Stage::send_structures_to_render() {
            //TODO: do this smarter with spatial partition
            for(size_t i = 0; i < structures_.size(); ++i) {
                const auto& struct_entry = structures_[i];

                const auto& meta = Game::Meta::Structures().info()[static_cast<size_t>(struct_entry.meta_id)];
                size_t priority =
                   meta.flat == -1
                       ? static_cast<size_t>((struct_entry.depth) * 0x200000 + struct_entry.meta_id * 0x100 + 0x05):
                         static_cast<size_t>((struct_entry.depth) * 0x20000000 + struct_entry.meta_id * 0x100 + 0x05);

                if(meta.flat == -1 && meta.id != 48) {
                    render_queue_.push(std::make_tuple(priority, i, renderer_kind::structure_shadow));
                }
                render_queue_.push(std::make_tuple(priority, i, renderer_kind::structure));
                if(meta.full_height > meta.tile_height) {
                    render_queue_.push(std::make_tuple(priority % 0x100, i, renderer_kind::structure_bottom));
                    if(meta.flat == -1) {
                        render_queue_.push(std::make_tuple(priority % 0x100, i, renderer_kind::structure_bottom_shadow));
                    }
                }
            }
        }

        void Stage::update_scrolling() {
            update_scrolling(0, window_width_, 0, window_height_);
        }

        void Stage::update_tile(uint8_t i, uint8_t j) {
            update_tile(i, j, 0, window_width_, 0, window_height_);
        }

        void Stage::update_tile(uint8_t i, uint8_t j, uint16_t left, uint16_t right, uint16_t top, uint16_t bottom) {
            int32_t high_row[33];
            int32_t low_row[33];

            int32_t start_x = -static_cast<int32_t>(render_shared_.camera_x) - 0x100;
            const TileEntry& current_tile = tile_map_ptr_->get_tile(i, j);
            int32_t y = static_cast<int32_t>(current_tile.tile_j - 8) * 32 - static_cast<int32_t>(render_shared_.camera_y);
            const int32_t x0 = start_x + static_cast<int32_t>(current_tile.tile_i * 32);
            const int32_t x1 = x0 + 32;

            if(x0 >= static_cast<int32_t>(right))
                return;

            uint32_t tile_id = current_tile.tile_id;

            auto tlh = current_tile.corners.top_left_height;
            auto trh = current_tile.corners.top_right_height;
            auto blh = current_tile.corners.bottom_left_height;
            auto brh = current_tile.corners.bottom_right_height;

            int32_t y0_top = y - static_cast<int32_t>(tlh);
            int32_t y1_top = y - static_cast<int32_t>(trh);
            int32_t y0_bottom = (y - static_cast<int32_t>(blh)) + 32;
            int32_t y1_bottom = (y - static_cast<int32_t>(brh)) + 32;

            uint8_t row_id = tile_id & 0xF;
            uint8_t column_id = (tile_id & 0xF0) / 0x10;
            uint8_t terrain_id = (tile_id / 0x100) & 0x3;

            if(terrain_id == 2 && row_id > 7) {
                row_id = 7;
            } else if(terrain_id != 2 && row_id > 13) {
                row_id = 13;
            }

            if(terrain_id == 3 && column_id > 3) {
                column_id = 3;
            }

            if((y0_bottom >= top ||
                y1_bottom >= top)
                &&
               (y0_top < static_cast<int32_t>(bottom) ||
                y1_top < static_cast<int32_t>(bottom))
                &&
                x1 > left
                &&
                x0 < static_cast<int32_t>(right)
            ) {

                brezenham(x0, y0_top, x1, y1_top, [&](auto xx, auto yy) {
                    uint8_t id = static_cast<uint8_t>(xx - x0);
                    low_row[id] = yy;
                });
                brezenham(x0, y0_bottom, x1, y1_bottom, [&](auto xx, auto yy) {
                    uint8_t id = static_cast<uint8_t>(xx - x0);
                    high_row[id] = yy;
                });

                uint8_t corrected_tile_id = (column_id * 0x10) | row_id;

                const uint8_t WATER_SCROLLING_TICKS = 4;

                auto woffset = (water_offset_ / WATER_SCROLLING_TICKS) * 4;

                if(terrain_id == 2) {
                    column_id = (column_id + woffset) % 16;
                }

                auto tile_sprite = tiles_[terrain_id][column_id];
                auto tbuf = tile_sprite->buffer();
                auto tr = tile_sprite->red_palette();
                auto tg = tile_sprite->green_palette();
                auto tb = tile_sprite->blue_palette();

                for(uint8_t u = 0; u < 32; ++u) {
                    __m128i u_vect = _mm_set1_epi16(u);
                    int32_t cx = x0 + u;
                    if(cx < 0 || cx >= right) continue;

                    int32_t ly = low_row[u];
                    int32_t hy = high_row[u];

                    int32_t cy = ly;
                    uint16_t h_diff = static_cast<uint16_t>(hy - ly);

                    if(h_diff > 64000) {
                        h_diff = 0;
                    }
                    auto scaler_array = ACQUIRE_HEIGHT_SCALER(h_diff);

                    for(uint8_t v = 0; v < 32; ++v) {
                        for(uint8_t zz = scaler_array[v]; zz; --zz) {
                            if(cy >= 0 && cy < bottom) {
                                int32_t stride_dest = cy * window_width_ + cx;

                                render_shared_.terrain_tile_high_byte_cache[stride_dest] = terrain_id;
                                render_shared_.terrain_tile_low_byte_cache[stride_dest] = corrected_tile_id;
                                render_shared_.terrain_tile_u_cache[stride_dest] = u;
                                render_shared_.terrain_tile_v_cache[stride_dest] = v;
                                render_shared_.terrain_tile_i_cache[stride_dest] = static_cast<uint8_t>(i);
                                render_shared_.terrain_tile_j_cache[stride_dest] = static_cast<uint8_t>(j);

                                auto tile_stride = 32 * (row_id * 32 + v) + u;

                                uint32_t loffs = j * 256 + i;
                                uint32_t loffs2 = loffs + 256;

                                uint16_t lside[8] = {0,0,0,0,0,0,0,0};
                                uint16_t rside[8] = {0,0,0,0,0,0,0,0};

                                lside[0] = lightness_map[loffs];
                                lside[1] = fov_map_shifted[loffs++];

                                rside[0] = lightness_map[loffs];
                                rside[1] = fov_map_shifted[loffs];

                                lside[2] = lightness_map[loffs2];
                                lside[3] = fov_map_shifted[loffs2++];

                                rside[2] = lightness_map[loffs2];
                                rside[3] = fov_map_shifted[loffs2];

                                auto ls = _mm_loadu_si128(reinterpret_cast<__m128i*>(lside));
                                auto rs = _mm_loadu_si128(reinterpret_cast<__m128i*>(rside));

                                _mm_storeu_si128(reinterpret_cast<__m128i*>(lside),
                                    _mm_add_epi16(
                                        _mm_mullo_epi16(u_vect, _mm_sub_epi16(rs, ls)),
                                        _mm_slli_epi16(ls, 5)
                                    )
                                );

                                uint8_t lc = (32 * lside[0] + (lside[2] - lside[0]) * v) / 1024;
                                uint8_t fc = (32 * lside[1] + (lside[3] - lside[1]) * v) / 1024;
                                fc = (fc*fc) / 256;

                                uint32_t pal_stride = 0x10 * tbuf[tile_stride] + lc;

                                tiles_sprite_.lock([&](auto tsw, auto tsh, auto rb, auto gb, auto bb)
                                {
                                    rb[stride_dest] = tr[pal_stride];
                                    gb[stride_dest] = tg[pal_stride];
                                    bb[stride_dest] = tb[pal_stride];
                                });
                                screen_space_fov_[stride_dest] = ((255 - fc) / 16) * 17;
                            }
                            ++cy;
                        }
                        if(cy >= bottom)
                            break;
                    }
                }
            }
        }

        void Stage::update_water_tiles() {
            const uint32_t top_y = render_shared_.camera_y;
            const uint32_t bottom_y = render_shared_.camera_y + window_height_;
            const uint32_t right_x = render_shared_.camera_x + window_width_;
            const uint32_t left_x = render_shared_.camera_x;

            const uint16_t corr8 = 0x100;

            uint32_t ltile = (left_x + corr8) / 32;
            uint32_t rtile = (right_x + corr8) / 32;
            uint32_t ttile = (top_y+ corr8) / 32;
            uint32_t btile = (bottom_y + corr8) / 32;
            if(ttile >= 8) ttile -= 8;
            else ttile = 0;
            if(btile <= tile_map_ptr_->height()-9) btile += 8;
            else btile = static_cast<uint32_t>(tile_map_ptr_->height()-1);
            if(ltile >= 1) --ltile;
            if(rtile <= tile_map_ptr_->width()-2) ++rtile;
            for(size_t j = ttile; j <= btile; ++j) {
                for(size_t i = ltile; i <= rtile; ++i) {
                    if(static_cast<int32_t>((i-7) * 32) < static_cast<int32_t>(render_shared_.camera_x)) {
                        continue;
                    }
                    if(static_cast<int32_t>((i-8) * 32) >= static_cast<int32_t>(right_x)) {
                        continue;
                    }
                    const auto& tile = tile_map_ptr_->get_tile(i, j);
                    if(tile.tile_id & 0x200) update_tile(static_cast<uint8_t>(i), static_cast<uint8_t>(j));
                }
            }
        }

        void Stage::update_scrolling(uint16_t left, uint16_t right, uint16_t top, uint16_t bottom) {
            const uint32_t top_y = render_shared_.camera_y + top;
            const uint32_t bottom_y = render_shared_.camera_y + bottom;
            const uint32_t right_x = render_shared_.camera_x + right;
            const uint32_t left_x = render_shared_.camera_x + left;

            const uint16_t corr8 = 0x100;

            uint32_t ltile = (left_x + corr8) / 32;
            uint32_t rtile = (right_x + corr8) / 32;
            uint32_t ttile = (top_y+ corr8) / 32;
            uint32_t btile = (bottom_y + corr8) / 32;
            if(ttile >= 8) ttile -= 8;
            else ttile = 0;
            if(btile <= tile_map_ptr_->height()-9) btile += 8;
            else btile = static_cast<uint32_t>(tile_map_ptr_->height()-1);
            if(ltile >= 1) --ltile;
            if(rtile <= tile_map_ptr_->width()-2) ++rtile;

            for(size_t j = ttile; j <= btile; ++j) {
                for(size_t i = ltile; i <= rtile; ++i) {
                    if(static_cast<int32_t>((i-7) * 32) < static_cast<int32_t>(render_shared_.camera_x)) {
                        continue;
                    }
                    if(static_cast<int32_t>((i-8) * 32) >= static_cast<int32_t>(right_x)) {
                        continue;
                    }
                    update_tile(static_cast<uint8_t>(i), static_cast<uint8_t>(j), left, right, top, bottom);
                }
            }
        }

        void Stage::draw_tiles(SOASpriteRGB& back_sprite) {
            tiles_sprite_.blit_on_sprite(back_sprite, 0, 0);
        }

        void Stage::draw_wireframe(SOASpriteRGB& back_sprite) {
//            const std::vector<TileMapChunk>& tilemap_chunks = tile_map_ptr_->get_chunks();
//            back_sprite.lock([&](auto dw, auto dh, auto rbuf, auto gbuf, auto bbuf) {
//                auto plotter = [&](auto x, auto y) {
//                    if(x < 0 || y < 0 || x >= dw || y >= dh) return;
//                    auto stride = x + y * dw;
//                    rbuf[stride] = 0xFF;
//                    gbuf[stride] = 0x20;
//                    bbuf[stride] = 0x20;
//                };

//                const uint32_t bottom_y = render_shared_.camera_y + window_height_;
//                const uint32_t right_x = render_shared_.camera_x + window_width_;

//                for(size_t i = 0; i < tilemap_chunks.size(); ++i) {
//                    const TileMapChunk& current_chunk = tilemap_chunks[i];
//                    if(current_chunk.max_y < static_cast<int32_t>(render_shared_.camera_y)) {
//                        continue;
//                    }
//                    if(current_chunk.min_y >= static_cast<int32_t>(bottom_y)) {
//                        continue;
//                    }
//                    if(current_chunk.max_x < static_cast<int32_t>(render_shared_.camera_x)) {
//                        continue;
//                    }
//                    if(current_chunk.min_x >= static_cast<int32_t>(right_x)) {
//                        continue;
//                    }

//                    int32_t x0 = (current_chunk.start_tile_i - 8) * 32 - static_cast<int32_t>(render_shared_.camera_x);
//                    int32_t x1 = x0 + 32;
//                    int32_t y = (current_chunk.tile_j - 8) * 32 - static_cast<int32_t>(render_shared_.camera_y);

//                    for(size_t k = 0; k < 16; k += 2) {
//                        if(x0 <= -32 || x0 >= dw) {
//                            x0 = x1;
//                            x1 += 32;
//                            continue;
//                        }
//                        int32_t y0_top = y - current_chunk.top_heights[k];
//                        int32_t y1_top = y - current_chunk.top_heights[k+1];
//                        int32_t y0_bottom = y + 32 - current_chunk.bottom_heights[k];

//                        brezenham(x0, y0_top, x1, y1_top, plotter);
//                        brezenham(x0, y0_top, x0, y0_bottom, plotter);

//                        x0 = x1;
//                        x1 += 32;
//                    }
//                }
//            });
        }
    }
}
